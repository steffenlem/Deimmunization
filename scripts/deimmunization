#!/usr/bin/env python

import numpy as np
import matplotlib.pyplot as plt
import click
import logging

from src.MSAParser.model.MSA import MSA
from src.netMHCIIpanParser.netMHCIIparser import parse_netMHCIIpan
from src.sequence_information.SequenceInformation import SequenceInformation
from src.mutationRules.mutationRules import mutation_order_by_group
from src.PointMutation.PointMutation import PointMutation

console = logging.StreamHandler()
formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
console.setFormatter(formatter)
LOG = logging.getLogger("Commandline parser")
LOG.addHandler(console)
LOG.setLevel(logging.INFO)


# sudo python3 setup.py install
# deimmunization -in /home/steffen/Documents/Deimmunization/data/Isomerase_90_similarity.clustal_num -rs 2WCV_Paris -t 0.5 -a DRB1_1501 -p /home/steffen/netMHCIIpan-3.2/netMHCIIpan


@click.command()
@click.option('-in', '--input_msa', prompt='input msa',
              help='file path to msa.txt', required=True)
@click.option('-rs', '--reference_sequence', prompt='reference sequence',
              help='titlestring of reference sequence', required=True)
@click.option('-t', '--majority_threshold', prompt='majority threshold',
              help='value between 0 and 1 to decide the consensus value', required=True, default=0.5)
@click.option('-a', '--mhc_allele', prompt='MHC allele',
              help='MHC class II allel e.g. DRB1_0101', required=True)
@click.option('-p', '--mhc_ii_pan', prompt='MHCIIpan',
              help='path to netMHCIIpan', required=True)
def main(input_msa, reference_sequence, majority_threshold, mhc_allele, mhc_ii_pan):
    # Construct an MSA Object, which contains the information about the MSA
    my_msa = MSA(input_msa, reference_sequence, majority_threshold)
    my_msa.write_sequnce('data/ref_sequence.fasta')

    # Predict the Epitopes using netMHCIIpan and parse the output of netMHCIIpan to
    parsed_data = parse_netMHCIIpan(mhc_ii_pan, 'data/ref_sequence.fasta', mhc_allele)
    parsed_data2 = parse_netMHCIIpan(mhc_ii_pan, 'data/ref_sequence.fasta', 'DRB1_0701')
    parsed_data3 = parse_netMHCIIpan(mhc_ii_pan, 'data/temp.fasta', 'DRB1_0301')

    # Information about the sequenece (eptitopes, msa, ...) is bundled
    target_sequence = SequenceInformation(my_msa.get_sequence(), my_msa.get_consensus_sequence())
    target_sequence.set_allele_prediction(parsed_data)
    target_sequence.set_allele_prediction(parsed_data2)
    target_sequence.set_allele_prediction(parsed_data3)
    target_sequence.calculate_base_immunogenicity()
    target_sequence.calculate_binding_core()
    target_sequence.make_queue_mutation()


    # Settings for the deimmunization
    number_mutations = 5
    positions_to_check = 3

    # variables
    inital_immunigenicity = target_sequence.base_immunogenicity
    final_mutations = []
    queue = target_sequence.queue


    print('Base:'+ str(target_sequence.base_immunogenicity))


    # Loop deimmunization
    while number_mutations > len(final_mutations):
        # create temporary sequence class
        temp_sequence = SequenceInformation(my_msa.get_sequence(), my_msa.get_consensus_sequence())
        temp_sequence.introduce_mutations(final_mutations)

        temp_sequence.write_sequence('data/temp.fasta')

        prediction_data = parse_netMHCIIpan(mhc_ii_pan, 'data/temp.fasta', mhc_allele)
        prediction_data2 = parse_netMHCIIpan(mhc_ii_pan, 'data/temp.fasta', 'DRB1_0701')
        prediction_data3 = parse_netMHCIIpan(mhc_ii_pan, 'data/temp.fasta', 'DRB1_0301')

        temp_sequence.set_allele_prediction(prediction_data)
        temp_sequence.set_allele_prediction(prediction_data2)
        temp_sequence.set_allele_prediction(prediction_data3)
        temp_sequence.calculate_base_immunogenicity()
        temp_sequence.calculate_binding_core()
        temp_sequence.make_queue_mutation()

        # Update queue
        queue = temp_sequence.queue

        # Remove already edited residues from queue
        for point_mutation in final_mutations:
            try:
                queue.remove(point_mutation.index)
            except ValueError:
                pass

        # Update immunogenicity
        current_immunogenicity = temp_sequence.base_immunogenicity

        # Indroduced muations
        current_mutations = []

        for x in range(positions_to_check):
            # index of residue to mutate
            position = queue[x]

            current_residue = temp_sequence.get_sequence_pos(position)
            current_amino_group = temp_sequence.msa[position][1]

            print(current_residue)
            print(current_immunogenicity)
            print(current_amino_group)

            # List of amino acids to check  # TODO braucht man eigentlich gar nicht wenn man eh alle testet...
            mutations_to_check = mutation_order_by_group[current_amino_group].copy()
            mutations_to_check.remove(current_residue)

            for aa in mutations_to_check:
                current_mutations.append(
                    PointMutation(aa, position, temp_sequence.update_immunogenicity(aa, position, mhc_ii_pan), 0))
        final_mutations.append(decision_function(current_mutations))

    # Print final mutations
    for x in final_mutations:
        print(x.__str__())


    # create new sequence
    new_sequence = SequenceInformation(my_msa.get_sequence(), my_msa.get_consensus_sequence())
    new_sequence.introduce_mutations(final_mutations)
    new_sequence.write_sequence('data/new_sequence.fasta')
    prediction_data = parse_netMHCIIpan(mhc_ii_pan, 'data/new_sequence.fasta', mhc_allele)
    prediction_data2 = parse_netMHCIIpan(mhc_ii_pan, 'data/new_sequence.fasta', mhc_allele)
    prediction_data3 = parse_netMHCIIpan(mhc_ii_pan, 'data/new_sequence.fasta', mhc_allele)
    new_sequence.set_allele_prediction(prediction_data)
    new_sequence.set_allele_prediction(prediction_data2)
    new_sequence.set_allele_prediction(prediction_data3)
    new_sequence.calculate_base_immunogenicity()
    new_sequence.calculate_binding_core()

    print('Base:' + str(new_sequence.base_immunogenicity))




    # plot epitopes

    plot_epitopes(target_sequence.get_length_sequence(), target_sequence.part_of_core_pos)
    plot_epitopes(new_sequence.get_length_sequence(), new_sequence.part_of_core_pos)


def decision_function(mutations):
    best_mutation = PointMutation('', -1, float('inf'), float('-inf'))
    for x in mutations:
        if x.immunogenicity < best_mutation.immunogenicity:
            best_mutation = x
    return best_mutation


def plot_epitopes(length_sequence, epitopes):
    plotable_data = np.zeros(int(length_sequence))
    for x in epitopes:
        plotable_data[x[0]] = x[1]
    plt.plot(plotable_data)
    plt.show()


if __name__ == '__main__':
    main()
